# Обмен данными между МК с использованием азбуки Морзе

## 1. Общее описание

Данный проект реализует **полудуплексную систему связи** между двумя микроконтроллерами по GPIO-линии с использованием **азбуки Морзе**.

Каждый МК может работать **и как передатчик, и как приёмник**.

Передача и приём реализованы **неблокирующим образом**, с активным использованием:

* аппаратного таймера (Timer1, 1 мс тик),
* внешних прерываний GPIO,
* конечных автоматов,
* кольцевых буферов.

---

## 2. Поддерживаемые режимы

### 2.1 Automatic / Serial (ASCII)

```
ASCII (Serial) → Морзе → GPIO → Морзе → ASCII → 7-seg
```

* Символы принимаются по `Serial`
* Кодируются в Морзе
* Передаются по TX-линии
* На принимающей стороне декодируются и отображаются

---

### 2.2 Manual / Normal

```
Sensor → обработка → Морзе → GPIO → Морзе → ASCII
```

* Сигнал с Sensor pin обрабатывается программно
* Применяется дебаунс и восстановление таймингов
* Используется та же логика передачи, что и в автоматическом режиме

---

### 2.3 Raw-режим

```
Sensor → GPIO → Морзе → ASCII
```

* **Цифровой сигнал** с Sensor pin напрямую транслируется на TX
* **Нет фильтрации, интерпретации и восстановления таймингов**
* Используется только для цифровых источников
* Аналоговый сигнал должен быть предварительно оцифрован

Приёмник **не знает**, в каком режиме работал передатчик.

---

## 3. Аппаратная схема

### Используемые пины (Arduino AVR):

| Назначение     | Пин |
| -------------- | --- |
| Sensor input   | D2  |
| RX (Interrupt) | D3  |
| TX             | D4  |
| 74HC595 DATA   | D8  |
| 74HC595 CLOCK  | D6  |
| 74HC595 LATCH  | D7  |

* RX и Sensor используют `INPUT_PULLUP`
* Передача — цифровой HIGH/LOW

---

## 4. Кодирование Морзе

### Временные единицы (TU)

| Элемент                | Длительность |
| ---------------------- | ------------ |
| Точка                  | 1 TU         |
| Тире                   | 3 TU         |
| Пауза между элементами | 1 TU         |
| Пауза между буквами    | 3 TU         |
| Пауза между словами    | 7 TU         |

`TIME_UNIT_MS = 50 мс`

---

## 5. Примерная визуализация протокола передачи

```
Время --->
   idle start  dot  pause    slash        letter pause       slash      pause dot     stop
...‾‾‾‾‾|____|‾‾‾‾‾|____|‾‾‾‾ ‾‾‾‾ ‾‾‾‾|____ ____ ____|‾‾‾‾ ‾‾‾‾ ‾‾‾‾|____|‾‾‾‾|____|‾‾‾‾...
          |
     начало передачи
```

* HIGH — активный сигнал (точка / тире)
* LOW — паузы
* Декодирование основано **исключительно на измерении длительностей**

---

## 6. Приём и декодирование

Приём реализован **событийно**:

* GPIO interrupt → фиксация момента изменения
* Timer interrupt → проверка дебаунса и таймингов
* Конечный автомат:

  * HIGH → определение DOT / DASH
  * LOW → ELEMENT / LETTER / WORD pause
* Таймаут завершает символ, если сигнал пропал

---

## 7. Буферы и неблокирующая архитектура

* Используются **кольцевые буферы**:

  * TX buffer
  * RX buffer
* Буферы защищены `cli()/sei()`
* Пользовательский ввод не теряется
* Передача и приём работают независимо от `loop()`

---

## 8. Конечные автоматы

### Передатчик (TX)

Состояния:

* `WAIT_LETTER`
* `BIT`
* `PAUSE`

Логика:

```
[есть символ] → BIT
[бит отправлен] → PAUSE
[конец буквы] → WAIT_LETTER
```

---

### Приёмник (RX)

Состояния логические:

* HIGH интервал → DOT / DASH
* LOW интервал → пауза
* TIMEOUT → завершение символа

---


## 9. Особенности реализации

### 9.1 Буферизация данных

В системе используются **кольцевые буферы** для передачи и приёма данных:

* `TX buffer` — очередь символов на отправку
* `RX buffer` — очередь принятых и декодированных символов

Особенности:

* Буферы неблокирующие
* Защищены от гонок с помощью `cli()/sei()`
* Пользовательский ввод **не теряется**, даже если передача медленнее ввода
* Передача и приём не зависят от скорости `loop()`

---

### 9.2 Коррекция дребезга и устойчивость к шуму

Для обработки нестабильных сигналов применяется **двухуровневая защита**:

1. **Debounce timeout**

   * Используется параметр `DEBOUNCE_MAX_LIMIT_MS`
   * Изменение уровня считается валидным только если сигнал стабилен дольше заданного времени

2. **Округление длительностей**

   * Измеренные интервалы переводятся в `TU`
   * Далее интерпретируются через диапазоны:

     * DOT / DASH
     * ELEMENT / LETTER / WORD pause
   * Это позволяет корректно декодировать сигнал даже при неточностях таймингов

Таким образом достигается устойчивость к:

* дребезгу контактов
* неидеальной ручной передаче
* джиттеру таймера

---

### 9.3 Неблокирующая архитектура

Вся система построена **без delay и busy-wait циклов**:

* Тайминги обрабатываются в `Timer1 ISR`
* Изменения уровней — через GPIO interrupt
* `loop()` используется только для:

  * чтения Serial
  * отображения символов
  * смены режимов

**Приём и передача могут выполняться одновременно**, так как:

* RX и TX используют независимые конечные автоматы
* Передача не блокирует приём и наоборот

---

### 9.4 Генерация словарей Морзе

Все таблицы соответствия:

* ASCII → Morse
* Morse → ASCII
* ASCII → 7-segment

**генерируются автоматически** с помощью [Python-скрипта](/MorseCode/gen_morse_code_maps.py):

Преимущества подхода:

* легко изменять или расширять алфавит
* исключены ошибки ручного заполнения таблиц
* упрощается поддержка проекта
* возможно добавление:

  * новых символов
  * альтернативных кодировок
  * других типов индикаторов

---



## 10. START / END кадрирование

Архитектура поддерживает кадрированную передачу:

```
[START] [PAYLOAD] [END]
```

* START / END — специальные последовательности Морзе
* В текущей реализации:

  * PAYLOAD принимается корректно
  * START/END могут быть добавлены без изменения RX-логики
* Приёмник способен принять или отклонить сообщение логически

---

## 11. Ограничения реализации

### Временные ограничения

* TU могут изменяться по длительности
* **Порядок соотношений обязателен**:

```
DOT_TU < DASH_TU
ELEMENT_PAUSE_TU < LETTER_PAUSE_TU < WORD_PAUSE_TU
```

Например:

> `ELEMENT_PAUSE_TU` **не может быть больше** `LETTER_PAUSE_TU`

---


## 12. Итог

Проект демонстрирует:

* симметричную полудуплексную связь,
* корректную работу raw и normal режимов,
* использование аппаратных возможностей МК,
* неблокирующую архитектуру,
* устойчивое декодирование Морзе по времени.

Готов к расширению (ACK, CRC, START/END, word buffering).

---

## Ссылки

* **[Видео-демонстрация работы]()**
* **[Tinkercad-схема подключения](https://www.tinkercad.com/things/7JcgediYPwC-morsecode?sharecode=QHoknt5JgFA99c_mac4HU8cTO0DhXg_a1LF5GdQfdsU)**
