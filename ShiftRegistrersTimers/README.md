# Управление двумя семисегментными индикаторами через каскад 74HC595

## Краткое описание решения

В проекте используется два сдвиговых регистра 74HC595, подключённых каскадно, чтобы задействовать всего 3 вывода Arduino для управления сегментами двух индикаторов. Обновление отображения и инкремент секунд выполняются по прерываниям аппаратного таймера (Timer1), без `delay()`. Главный цикл (`loop`) обрабатывает ввод по `Serial` и безопасно передаёт новое двузначное значение в переменные, доступные ISR.

Код не использует `digitalWrite()`, `shiftOut()` или `delay()` — вместо этого применяется прямой доступ к регистрам порта `PORTD` и собственная функция `shiftOutByte()`.

---

## Аппаратные требования и подключения

### Необходимые детали

* Arduino Uno (ATmega328P)
* 2 × 74HC595 (каскад)
* 2 × 7-сегментных индикатора (общий анод или общий катод — определяется флагом в коде)
* 16 × резисторов тока (220–330 Ω) — по одному на каждый сегмент/анод/катод в зависимости от схемы
* Макетная плата и провода
* USB-кабель для загрузки программы и Serial

### Пины (в коде)

Код использует биты порта D:

* `DATA` (DS)  — PD7
* `CLOCK` (SH_CP) — PD3
* `LATCH` (ST_CP) — PD5

Эти маски определены в начале кода:

```c
const uint8_t LATCH_PIN_MASK  = (1 << PD5); // ST_CP (Latch)
const uint8_t CLOCK_PIN_MASK  = (1 << PD3); // SH_CP (Clock)
const uint8_t DATA_PIN_MASK   = (1 << PD7); // DS (Data)
```

### Подключение

1. Соедините Q7' (вывод 9) первого 74HC595 с DS (DATA) Arduino (PD7).
2. SH_CP (Clock) на PD3.
3. ST_CP (Latch) на PD5.
4. Q7' (serial out) первого 74HC595 —> DS второго 74HC595 (каскад).
5. Выходы QA–QH каждого 74HC595 — через резисторы — к сегментам соответствующего семисегмента.
6. Общий анод/катод индикаторов — к источнику питания / земле в зависимости от типа (см. флаг `COMMON_ANODE` / `COMMON_CATHODE`).

---

## Флаг типа индикатора

Вверху кода есть директивы:

```c
// #define COMMON_ANODE
#define COMMON_CATHODE
```

Раскомментируйте нужную строку:

* `COMMON_CATHODE` — в матрицах набора битов 1 включает сегмент.
* `COMMON_ANODE` — логика инвертирована (0 включает сегмент).

---

## Логика кода — обзор файловых функций и переменных

### Ключевые глобальные переменные

* `volatile uint32_t current_millis` — счётчик миллисекунд, увеличивается в ISR Timer1.
* `volatile uint32_t next_call_millis` — метка времени для следующего вызова обновления (интервал 1000 ms).
* `const uint16_t FUNC_CALL_INTERVAL_MS = 1000` — интервал 1 секунда.
* `volatile int number_to_show` — текущее двузначное число для отображения; `-1` — пока не задано.
* `volatile bool need_to_show` — флаг, сигнализирующий что был получен ввод и нужно отобразить значение сразу.
* `firstDigit`, `secondDigit` — временное хранение цифр, собираемых из последовательного ввода.

### Таблица соответствия цифр (массив `digits[]`)

Массив `digits[10]` содержит байты, описывающие включение сегментов для цифр 0–9. Формат заполнения — для выбранного типа индикатора (CA/CC) предусмотрены разные значения. Есть также `empty_segments`, используемый для отображения ведущего нуля как пустого (скрытого).

> Обратите внимание: в массиве использовано конкретное битовое соответствие `AB.CDEGF` — важно, чтобы это соответствовало проводке сегментов к выходам 74HC595.

### Управление портами

Функции `pinHigh(mask)` и `pinLow(mask)` пишут напрямую в `PORTD` (операции OR / AND с маской). `setPinModeOutput(mask)` настраивает `DDRD`.

### Отправка байта в 74HC595

`shiftOutByte(dataPinMask, clockPinMask, val)` — реализует LSB-first сдвиг (по битам `i = 0..7`), вручную формирует такты на `clockPinMask` и управляет `dataPinMask`.

`showByte(b)` делает `latch LOW` → сдвиг 8 бит → `latch HIGH` (обновление выходов).

### Показ числа / цифр

* `showDigit(index)` — показывает одну цифру (использует `digits[index]`).
* `showNumber(num)` — показывает двузначное число: если старшая цифра равна 0 — выводятся `empty_segments` (т.е. ведущий ноль скрыт), затем младшая цифра.

### Таймер и ISR

* `setupInterrupts()` настраивает **Timer1** в режиме CTC (OCR1A = 249) с предделителем 64 → прерывание каждые 1 мс (при F_CPU = 16 MHz). В прерывании (`ISR(TIMER1_COMPA_vect)`) `current_millis` увеличивается, и при достижении `next_call_millis` происходит инкремент `next_call_millis` и вызов `showTimeOnClocks()`.

### Логика `showTimeOnClocks()`

* Если `number_to_show != -1`, то:

  * Если `start_value < 0` — фиксируется `start_millis = current_millis` и `start_value = number_to_show`.
  * Если `need_to_show` == `true` — непосредственно отображается `number_to_show` (пользовательское значение) и `need_to_show` сбрасывается, а `firstDigit/secondDigit` очищаются.
  * Иначе вычисляются прошедшие секунды: `seconds = ((current_millis - start_millis)/1000 + start_value) % 60` и отображаются они (модулируя от 0 до 59).

> Итого: при получении нового значения оно отображается сразу (один раз), потом счётчик продолжает увеличиваться каждую секунду, начиная с присланного значения.

### Serial ввод (`loop`)

* Чтение байт из `Serial`.
* Если прочитан символ `'0'..'9'` — он трактуется как цифра. `firstDigit` и `secondDigit` сдвигаются: `secondDigit = firstDigit; firstDigit = digit;` — таким образом пользователь может ввести две цифры сразу или подряд (например, `42` или `4` затем `2` для “42”). После ввода переменная `number_to_show` записывается в критической секции (вокруг `cli()`/`sei()`), и `need_to_show = true` устанавливается ранее.

---

## Выполнение требований задания — соответствие

**Требования и как они выполнены:**

* **Неблокирующая работа (без `delay()`):** выполнено — все интервалы реализованы через `Timer1`, основной цикл оставлен свободным для Serial.
* **Обновление по таймеру (ISR для clock/latch):** выполнено — обновление индикации и логика тайминга выполняются внутри ISR (вызывается `showTimeOnClocks()` из ISR). Формирование тактов/латча для 74HC595 выполняется функцией `showByte()` (вызов внутри ISR).
* **Инициализация через Serial:** выполнено — ввод цифр через монитор порта; при получении число сразу отображается.
* **Точная синхронизация счёта (каждую 1 сек):** выполнено — реализовано через миллисекундный тик Timer1 и проверку `current_millis`/`next_call_millis`. Это даёт 1-с точность с минимальным дрейфом при условии, что прерывания не долго блокируются.
* **Эффективность использования пинов:** использованы 3 управляющих пина Arduino (DATA, CLOCK, LATCH).
* **Портируемость (Tinkercad/реальное оборудование):** код использует стандартные регистры AVR и Arduino Serial — должен работать в Tinkercad и на реальном Arduino.
* **Синхронизация между main и ISR:** используется `volatile` и критическая секция (`cli()`/`sei()`) при записи `number_to_show`.
* **Поддержка CA и CC:** флаг `COMMON_ANODE`/`COMMON_CATHODE` обеспечивает выбор логики для сегментов.
* **Не используются `digitalWrite()`, `shiftOut()`, `delay()`:** выполнено.

---

## Пример использования

1. Загружаем прошивку.
2. В Serial Monitor вводим: `42`.
   — Индикатор: сразу `42`
   — Через секунду: `43`, затем `44`, и т.д.
3. В любой момент можно вводить новую пару цифр — следующее значение заменит текущее и будет отображено один раз, дальше счёт таймера продолжится.

---

## Ссылки

* **[Видео-демонстрация работы](https://disk.yandex.ru/i/Cptrpix3OekIeQ)**
* **[Tinkercad-схема подключения](https://www.tinkercad.com/things/0KRMY5Hgg6q-shiftregistrerstimers?sharecode=YKD9drDm3wNgmbYrd1Czht3_FJphJZ9VvXdJqC8XHMw)**

---

## Заключение

Предложенное решение демонстрирует основной подход к управлению семисегментными индикаторами через каскад 74HC595 с минимальным числом пинов, при этом реализована неблокирующая логика на базе аппаратного таймера (Timer1). Код покрывает требуемые пункты задания: аппаратное расширение, таймеры, Serial-инициализация и поддержка типа индикатора.

---
