# Реализация программного UART на Arduino с использованием GPIO и таймера

## Введение

UART (Universal Asynchronous Receiver/Transmitter) обеспечивает последовательную передачу данных по одному биту за раз. Каждое передаваемое слово включает:

* **Старт-бит** (LOW)
* **Данные** (обычно 8 бит, LSB первым)
* **Стоп-бит** (HIGH)

Передача и приём данных требуют точного соблюдения длительности бита, которая определяется выбранной скоростью передачи (baud rate). В нашем случае мы используем:

* **TX (передача)**: вывод PD3
* **RX (приём)**: вывод PD2
* **Таймер**: Timer1 с предделителем 8

Программу можно разделить на следующие ключевые компоненты:

1. Настройка GPIO и таймера
2. Реализация буферов TX и RX
3. Асинхронная передача данных через прерывания таймера
4. Асинхронный приём данных с детекцией старт-бита через внешнее прерывание

---

## Настройка пинов и таймера

Для корректной работы UART необходимо настроить пины и таймер:

```cpp
DDRD |= (1 << UART_TX_PIN);   // TX как выход
PORTD |= (1 << UART_TX_PIN);  // TX idle HIGH

DDRD &= ~(1 << UART_RX_PIN);  // RX как вход
PORTD |= (1 << UART_RX_PIN);  // RX Pull-up
```

Настройка таймера и прерываний:

```cpp
// Timer1 Prescaler 8
TCCR1A = 0;
TCCR1B = (1 << CS11);
TIMSK1 = 0; // Отключаем прерывания на старте

// Внешнее прерывание INT0 для детекции старта
EICRA = (1 << ISC01); // падающий фронт
EIMSK |= (1 << INT0);
```

Период таймера рассчитывается по формуле:

```
timer_ticks_per_bit = (F_CPU / prescaler) / baud_rate
```

Это позволяет точно управлять длительностью каждого бита.

---

## Буферы передачи и приёма

Используются кольцевые буферы размером 64 байта:

* **TX буфер**: хранит данные для отправки. Переменные `tx_head`, `tx_tail`, `tx_active`, `tx_byte_to_send`, `tx_bit_index` управляют состоянием передачи.
* **RX буфер**: хранит принятые данные. Переменные `rx_head`, `rx_tail`, `rx_active`, `rx_byte_received`, `rx_bit_index` управляют состоянием приёма.

Кольцевой буфер обеспечивает возможность непрерывной передачи и приёма данных с обработкой переполнения.

---

## Передача данных (TX)

Передача реализована через прерывание таймера `TIMER1_COMPA_vect`. Алгоритм:

1. Если передача не активна и буфер содержит данные, начинаем отправку.
2. Первый бит — старт-бит (LOW).
3. Далее отправляются 8 бит данных, начиная с младшего.
4. Завершается стоп-битом (HIGH).
5. После отправки одного байта проверяется буфер, если есть данные — отправка следующего байта продолжается.

Пример функции добавления байта в TX буфер:

```cpp
bool uart_send(char b) {
    uint8_t next_head = (tx_head + 1) % BUFFER_SIZE;
    if (next_head == tx_tail) return false; // Буфер переполнен

    tx_buffer[tx_head] = b;
    tx_head = next_head;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        if (!tx_active) {
            tx_active = true;
            tx_bit_index = 0;
            OCR1A = TCNT1 + 10; // Первое прерывание почти сразу
            TIMSK1 |= (1 << OCIE1A);
        }
    }
    return true;
}
```

Использование `ATOMIC_BLOCK` гарантирует корректное изменение переменных из прерываний без гонок данных.

---

## Приём данных (RX)

Приём данных требует более высокой точности, так как данные могут приходить в любой момент. Используется схема:

1. **Детекция старт-бита** через внешнее прерывание `INT0_vect` на PD2.
2. После детекции старт-бита активируется таймер `Timer1` для сэмплирования битов в середине каждого периода.
3. Считаются 8 бит данных, потом проверяется стоп-бит.
4. Принятый байт помещается в RX буфер, если он не переполнен.

Пример ISR детекции старта:

```cpp
ISR(INT0_vect) {
    if (rx_active) return;
    rx_active = true;
    rx_bit_index = 0;
    rx_byte_received = 0;
    EIMSK &= ~(1 << INT0); // временно отключаем INT0

    OCR1B = TCNT1 + timer_ticks_per_bit + (timer_ticks_per_bit / 2);
    TIMSK1 |= (1 << OCIE1B);
}
```

Выборка битов через `TIMER1_COMPB_vect`:

```cpp
ISR(TIMER1_COMPB_vect) {
    OCR1B += timer_ticks_per_bit;

    if (rx_bit_index < 8) {
        if (PIND & (1 << UART_RX_PIN)) rx_byte_received |= (1 << rx_bit_index);
        rx_bit_index++;
    } else {
        // Проверка стоп-бита и запись в буфер
        rx_active = false;
        TIMSK1 &= ~(1 << OCIE1B);
        EIMSK |= (1 << INT0); // Включаем INT0 обратно
    }
}
```

---

## Пользовательский интерфейс

Для работы с UART создаются удобные функции:

* `uart_send_string(const char *msg)` — отправка строки
* `uart_available()` — количество байт в RX буфере
* `uart_read()` — чтение одного байта
* `uart_read_string(char *rx_data)` — чтение всех доступных байт

Пример использования в `loop()`:

```cpp
void loop() {
    while (uart_available()) {
        char c = uart_read();
        Serial.write(c); // отображаем данные на Serial Monitor
        uart_send(c);    // отправляем эхо
    }
}
```

---

## Подключение двух Arduino

Для тестирования программы требуется соединить два Arduino:

* TX первого Arduino (PD3) → RX второго Arduino (PD2)
* GND первого Arduino → GND второго Arduino

На RX Arduino открыть монитор порта, будет переодично выводиться сообщение `Test packet MCU TX`

---

## Результаты работы

* Отправка символов реализована в фоновом режиме без блокировки основного цикла.
* RX имеет приоритет над TX и обеспечивает точный приём даже при высокой скорости передачи.

---

## Ссылки

* **[Видео-демонстрация работы](https://disk.yandex.ru/i/HvGt30dVlYRDXg)**
* **[Tinkercad-схема подключения](https://www.tinkercad.com/things/hXgGWvefWnr-myuart?sharecode=eRM3oxkymW2cGL30_Zsbr1iidcK3RLJORy9e7E6uJv8)**

---